{"ast":null,"code":"import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // item index to be made visible initially\n\n  var _useState = useState(),\n      scrollShow = _useState[0],\n      setScrollShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    }; // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };","map":{"version":3,"sources":["C:/Personal-Portfolio/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"names":["React","useEffect","useMemo","useRef","useState","useLayoutEffect","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","InfiniteScrollPropTypes","calculateLastPageBound","show","step","Math","floor","InfiniteScroll","_ref","children","_ref$items","items","onMore","renderMarker","replace","_ref$step","_useState","scrollShow","setScrollShow","lastPage","max","ceil","length","_useState2","renderPageBounds","setRenderPageBounds","_useState3","pageHeights","setPageHeights","_useState4","pendingLength","setPendingLength","aboveMarkerRef","belowMarkerRef","scrollParents","evaluate","scrollParent","top","height","document","documentElement","scrollTop","body","window","innerHeight","rect","getBoundingClientRect","offset","nextBeginPage","index","pagesHeight","nextEndPage","undefined","showPage","min","timer","debounce","clearTimeout","setTimeout","current","forEach","sp","addEventListener","removeEventListener","showIndex","showNode","parentNode","item","scrollIntoView","rendered","nextPageHeights","i","lastBottom","topIndex","bottomIndex","_rendered$item$getBou","bottom","concat","_nextPageHeights","aboveHeight","belowHeight","firstIndex","lastIndex","result","marker","createElement","key","ref","flex","cloneElement","push","slice","itemsIndex","child","_marker","renderedMarker","node","propTypes"],"mappings":"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","sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n\n  // item index to be made visible initially\n  var _useState = useState(),\n      scrollShow = _useState[0],\n      setScrollShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    }; // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };"]},"metadata":{},"sourceType":"module"}