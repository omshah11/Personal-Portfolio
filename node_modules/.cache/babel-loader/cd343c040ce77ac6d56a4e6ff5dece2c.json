{"ast":null,"code":"export var findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n\n  return result;\n};\nvar documentTags = ['html', 'body'];\nexport var findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    } // last scrollable element will be the document\n\n\n    result.push(document);\n  }\n\n  return result;\n};\nexport var containsFocus = function containsFocus(node) {\n  var element = document.activeElement;\n\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n\n  return !!element;\n}; // Check if the element.tagName is an input, select or textarea\n\nexport var isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n}; // Get the first element that can receive focus\n\nexport var getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n\n  return undefined;\n};\nexport var shouldKeepFocus = function shouldKeepFocus() {\n  var element = document.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\nexport var getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  } // setup DOM\n\n\n  var container = document.createElement('div');\n\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n\n  return container;\n};\nexport var setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\nexport var makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden'); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\nexport var makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabIndex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\nexport var findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\nexport var isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom; // target will be the document from findScrollParent()\n\n\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    height: 0,\n    top: 0\n  },\n      height = _ref.height,\n      top = _ref.top;\n\n  return bottom >= top + height;\n};\nexport var isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top; // target will be the document from findScrollParent()\n\n\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    top: 0\n  },\n      targetTop = _ref2.top;\n\n  return top <= targetTop;\n};","map":{"version":3,"sources":["C:/Personal-Portfolio/node_modules/grommet/es6/utils/DOM.js"],"names":["findScrollParent","element","horizontal","result","parent","parentNode","getBoundingClientRect","rect","width","scrollWidth","height","scrollHeight","document","tagName","toLowerCase","documentTags","findScrollParents","push","length","includes","containsFocus","node","activeElement","parentElement","isFocusable","getFirstFocusableDescendant","children","getElementsByTagName","i","child","undefined","shouldKeepFocus","getNewContainer","target","targetChildPosition","body","container","createElement","prepend","appendChild","setFocusWithoutScroll","x","window","scrollX","y","scrollY","focus","scrollTo","TABINDEX","TABINDEX_STATE","makeNodeFocusable","hasAttribute","removeAttribute","elements","Array","prototype","filter","call","forEach","prior","getAttribute","setAttribute","autoFocusingTags","makeNodeUnfocusable","currentTag","match","findVisibleParent","offsetParent","isNodeAfterScroll","_node$getBoundingClie","bottom","_ref","top","isNodeBeforeScroll","_node$getBoundingClie2","_ref2","targetTop"],"mappings":"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","sourcesContent":["export var findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n\n      parent = parent.parentNode;\n    } // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n\n\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n\n  return result;\n};\nvar documentTags = ['html', 'body'];\nexport var findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n\n  if (element) {\n    var parent = element.parentNode;\n\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect(); // 10px is to account for borders and scrollbars in a lazy way\n\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n\n      parent = parent.parentNode;\n    }\n\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    } // last scrollable element will be the document\n\n\n    result.push(document);\n  }\n\n  return result;\n};\nexport var containsFocus = function containsFocus(node) {\n  var element = document.activeElement;\n\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n\n  return !!element;\n}; // Check if the element.tagName is an input, select or textarea\n\nexport var isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n}; // Get the first element that can receive focus\n\nexport var getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n\n  return undefined;\n};\nexport var shouldKeepFocus = function shouldKeepFocus() {\n  var element = document.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\nexport var getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  }\n\n  // setup DOM\n  var container = document.createElement('div');\n\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n\n  return container;\n};\nexport var setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\nexport var makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden'); // allow children to receive focus again\n\n    var elements = node.getElementsByTagName('*'); // only reset elements we've changed in makeNodeUnfocusable()\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\nvar autoFocusingTags = /(a|area|input|select|textarea|button|iframe)$/;\nexport var makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true); // prevent children to receive focus\n\n    var elements = node.getElementsByTagName('*'); // first, save off the tabIndex of any element with one\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    }); // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\nexport var findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : findVisibleParent(element.parentElement) || element;\n  }\n\n  return undefined;\n};\nexport var isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      bottom = _node$getBoundingClie.bottom; // target will be the document from findScrollParent()\n\n\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    height: 0,\n    top: 0\n  },\n      height = _ref.height,\n      top = _ref.top;\n\n  return bottom >= top + height;\n};\nexport var isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n      top = _node$getBoundingClie2.top; // target will be the document from findScrollParent()\n\n\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n    top: 0\n  },\n      targetTop = _ref2.top;\n\n  return top <= targetTop;\n};"]},"metadata":{},"sourceType":"module"}